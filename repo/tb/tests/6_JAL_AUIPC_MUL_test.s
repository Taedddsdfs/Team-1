    .text
    .globl _start
_start:
    # x1 = 3, x2 = 7
    addi x1, x0, 3
    addi x2, x0, 7

    # ==========================
    # 1. 测试 MUL
    # ==========================
    mul  x3, x1, x2      # x3 = 21

    # ==========================
    # 2. 测试 JAL：跳过一条指令
    # ==========================
    jal  x4, label_after # x4 = PC+4 (return addr), PC 跳到 label_after

    # 这一条不能执行：
    addi x3, x0, 0       # 若执行了，会破坏 x3

label_after:
    # ==========================
    # 3. 测试 AUIPC：这里只是用来产生一个大一点的常数
    # ==========================
    auipc x5, 0x1        # x5 = PC + 0x1000 (我们不关心具体 PC，只要能运算即可)

    # ==========================
    # 4. 测试 JALR：用 x4 作为“返回地址基底”
    # ==========================
    # 假设 x4 现在是某个 PC+4，这里用 JALR 跳到 x4 本身：
    # jalr x0, 0(x4)       # 无需写 rd，rd=x0；PC = x4 & ~1
    addi x0, x0, 0

    # 理论上会跳回某个地址，如果你不想真的循环回来，可以略过这块；
    # 简化起见，就让程序向下执行，不依赖 JALR 的行为太严格。

    # 构造最终签名：
    # 仅依赖 MUL 的结果，以避免 AUIPC/JALR 引入的 PC 不确定性
    addi x10, x3, 1      # a0 = 22，如果 MUL 正确
done:
    beq x0, x0, done
